#include <iostream>#include <opencv2/opencv.hpp>using namespace cv;using namespace std;Mat HomoFilter(Mat inputImg) {	Mat homoImg = inputImg.clone();	Mat orginalImg = inputImg.clone();	homoImg.convertTo(homoImg, CV_64FC1);	int rows = homoImg.rows;	int cols = homoImg.cols;	//行列数调整为偶数	int m = rows % 2 == 1 ? rows + 1 : rows;	int n = cols % 2 == 1 ? cols + 1 : cols;	//对边界进行0填充	copyMakeBorder(homoImg, homoImg, 0, m - rows, 0, n - cols, BORDER_CONSTANT, Scalar::all(0));	//更新行列数	rows = homoImg.rows;	cols = homoImg.cols;	Mat homo_result_Img(rows, cols, CV_64FC1);	//取对数	for (int i = 0; i < rows; i++) {		double* srcdata = homoImg.ptr<double>(i);		double* logdata = homoImg.ptr<double>(i);		for (int j = 0; j < cols; j++) {			logdata[j] = log(srcdata[j] + 0.0001);//防止出现log0		}	}	//2. dct 离散余弦变换	Mat mat_dct = Mat::zeros(rows, cols, CV_64FC1);	dct(homoImg, mat_dct);	//3. 高斯同态滤波器	Mat H_u_v;	double Rh;//>1   高频增益	double Rl;//<1   低频增益	double C; //斜面锐化常数 斜率	double d0;//截止频率	d0 = max(cols, rows);	cout << "输入参数Rh";	cin >> Rh;	cout << "输入参数Rl";	cin >> Rl;	cout << "输入参数C";	cin >> C;	//cout << "输入参数d0";	//cin >> d0;	double  d2 = 0;	H_u_v = Mat::zeros(rows, cols, CV_64FC1);	for (int i = 0; i < rows; i++) {		double* dataH_u_v = H_u_v.ptr<double>(i);		for (int j = 0; j < cols; j++) {			d2 = pow((i - homoImg.rows / 2), 2.0) + pow((j - homoImg.cols / 2), 2.0);			dataH_u_v[j] = (Rh - Rl) * (1 - exp(-C * (d2 / d0))) + Rl;		}	}	H_u_v.ptr<double>(0)[0] = 1.5;	mat_dct = mat_dct.mul(H_u_v);	//反离散余弦变换	idct(mat_dct, homo_result_Img);	//去对数	for (int i = 0; i < rows; i++) {		double* srcdata = homo_result_Img.ptr<double>(i);		double* dstdata = homo_result_Img.ptr<double>(i);		for (int j = 0; j < cols; j++) {			dstdata[j] = exp(srcdata[j]) + 0.0001;		}	}	homo_result_Img.convertTo(homo_result_Img, CV_8UC1);	return homo_result_Img;}//YUV空间Mat YHomoFilter(Mat orginalImg){	int original_rows = orginalImg.rows;	int original_cols = orginalImg.cols;	Mat dst(original_rows, original_cols, CV_8UC3);	cvtColor(orginalImg, orginalImg, COLOR_BGR2YUV);//转换为YUV颜色空间	vector <Mat> yuvImg;	split(orginalImg, yuvImg);//将原始图像按通道拆分成三个单独的图像，分别对应YUV颜色空间的三个通道。	Mat nowY = yuvImg[0];//原始图像的亮度通道	Mat newY = HomoFilter(nowY);//对亮度通道进行同态滤波处理	Mat tempY(original_rows, original_cols, CV_8UC1);	for (int i = 0; i < original_rows; i++) {		for (int j = 0; j < original_cols; j++) {			tempY.at<uchar>(i, j) = newY.at<uchar>(i, j);		}	}	yuvImg[0] = tempY;	merge(yuvImg, dst);//经过处理的YUV通道图像重新合并为一张图像	cvtColor(dst, dst, COLOR_YUV2BGR);//转换回BGR颜色空间	return dst;}int main(){	Mat src = imread("F://test3.jpg");	namedWindow("src", 0);	resizeWindow("src", 400, 600);	imshow("src", src);	Mat homoImg = YHomoFilter(src);	namedWindow("homo", 0);	resizeWindow("homo", 400, 600);	imshow("homo", homoImg);	waitKey(0);	return 0;}